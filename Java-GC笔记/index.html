<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="juK8iKOrjF-CCSscN7oc59B1D3s1Er05CCm7qTEAbVQ">
  <meta name="baidu-site-verification" content="ipzsKxVcdo">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"chivalry727.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

<script data-ad-client="ca-pub-7512049882055371" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

  <meta name="description" content="垃圾收集器（Garbage Collection，GC）内存分配与回收的神秘面纱Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java的自动内存管理最核心的功能是Java Heap内存中对象的分配与回收。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java GC笔记">
<meta property="og:url" content="https://chivalry727.github.io/Java-GC%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Chivalry Blog">
<meta property="og:description" content="垃圾收集器（Garbage Collection，GC）内存分配与回收的神秘面纱Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java的自动内存管理最核心的功能是Java Heap内存中对象的分配与回收。">
<meta property="og:locale">
<meta property="og:image" content="http://wx1.sinaimg.cn/large/008aQ1h9ly1ghrccgxbicj30wm0u0413.jpg">
<meta property="article:published_time" content="2020-08-09T07:44:12.000Z">
<meta property="article:modified_time" content="2020-08-15T03:36:13.569Z">
<meta property="article:author" content="Mr.zxb">
<meta property="article:tag" content="GC">
<meta property="article:tag" content="Jvm内存分配">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://wx1.sinaimg.cn/large/008aQ1h9ly1ghrccgxbicj30wm0u0413.jpg">

<link rel="canonical" href="https://chivalry727.github.io/Java-GC%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Java GC笔记 | Chivalry Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Chivalry Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chivalry Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">从前很懒，从今以后约束自己</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://chivalry727.github.io/Java-GC%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://tva1.sinaimg.cn/large/008aQ1h9ly1ghqb9xxkl6j31ig3401kx.jpg">
      <meta itemprop="name" content="Mr.zxb">
      <meta itemprop="description" content="个人技术博客，一个沉淀知识的地方">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chivalry Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java GC笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-09 15:44:12" itemprop="dateCreated datePublished" datetime="2020-08-09T15:44:12+08:00">2020-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-15 11:36:13" itemprop="dateModified" datetime="2020-08-15T11:36:13+08:00">2020-08-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Jvm-%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Jvm 笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>9.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>9 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="垃圾收集器（Garbage-Collection，GC）"><a href="#垃圾收集器（Garbage-Collection，GC）" class="headerlink" title="垃圾收集器（Garbage Collection，GC）"></a>垃圾收集器（Garbage Collection，GC）</h3><h4 id="内存分配与回收的神秘面纱"><a href="#内存分配与回收的神秘面纱" class="headerlink" title="内存分配与回收的神秘面纱"></a>内存分配与回收的神秘面纱</h4><p>Java的自动内存管理主要是针对对象内存的回收和对象内存的分配。同时，Java的自动内存管理最核心的功能是<strong>Java Heap</strong>内存中对象的分配与回收。</p>
  <a id="more"></a>  

<h5 id="堆内存划分"><a href="#堆内存划分" class="headerlink" title="堆内存划分"></a>堆内存划分</h5><p>堆内存分为新生代、老年代和永久代。新生代又被进一步分为：Eden 区＋Survivor1 区＋Survivor2 区。值得注意的是，在 JDK8中移除永久代，取而代之的是一个叫元空间（Metaspace）的区域（永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制）</p>
<h5 id="对象优先在Edge区分配"><a href="#对象优先在Edge区分配" class="headerlink" title="对象优先在Edge区分配"></a>对象优先在Edge区分配</h5><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<ul>
<li><strong>新生代GC（Minor GC）</strong>: 指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>老年代GC（Major GC/Full GC）</strong>: 指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p>
<h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><p>既然虚拟机采用了分代收集的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。</p>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1，对象在 Survivor 中每熬过一次 MinorGC, 年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h5 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h5><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到了某个值才能进入老年代，如果 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p>
<h4 id="如何判断对象活着？"><a href="#如何判断对象活着？" class="headerlink" title="如何判断对象活着？"></a>如何判断对象活着？</h4><h5 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h5><ul>
<li>是在对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1；任何时刻计数器为0的对象就是不能再被使用</li>
<li>主流Java虚拟机并没有选用引用计数算法来管理内存</li>
<li>原因是该算法很难解决对象之间互相循环引用的问题<h5 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h5></li>
</ul>
<h6 id="什么是可达性分析算法"><a href="#什么是可达性分析算法" class="headerlink" title="什么是可达性分析算法"></a>什么是可达性分析算法</h6><p>通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走的路径称为“引用链（Reference Chain）”，如果某个对象到GC Roots间没有任何引用链相连或从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的</p>
<p><img src="http://wx1.sinaimg.cn/large/008aQ1h9ly1ghrccgxbicj30wm0u0413.jpg"></p>
<h6 id="什么是-GC-Roots对象"><a href="#什么是-GC-Roots对象" class="headerlink" title="什么是 GC Roots对象"></a>什么是 GC Roots对象</h6><ul>
<li>虚拟机栈中引用的对象，比如各线程调用方法堆栈中使用的参数、局部变量、临时变量等</li>
<li>方法区中类静态属性引用的对象，比如字符串常量池里的引用</li>
<li>方法区中类静态属性引用的对象，比如Java类的引用类型静态变量</li>
<li>本地方法栈中JNI引用的对象</li>
<li>Java虚拟机内部的引用，比如：基本数据类型对应的Class对象，以及一些异常对象（NPE、OOM）等，还有系统类加载器</li>
<li>所有被同步锁（synchronized关键字）持有的对象</li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等</li>
</ul>
<h4 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h4><p>无论通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象是否引用链可达，判定对象是否存活都和“引用“有关</p>
<h5 id="强引用（Strongly-Reference）"><a href="#强引用（Strongly-Reference）" class="headerlink" title="强引用（Strongly Reference）"></a>强引用（Strongly Reference）</h5><ul>
<li>不会被垃圾收集器回收掉的引用</li>
</ul>
<h5 id="软引用（Soft-Reference）"><a href="#软引用（Soft-Reference）" class="headerlink" title="软引用（Soft Reference）"></a>软引用（Soft Reference）</h5><ul>
<li>当JVM将要发生内存溢出前，会回收这部分引用，若内存还是不够，则OOM</li>
</ul>
<h5 id="弱引用（Weak-Reference）"><a href="#弱引用（Weak-Reference）" class="headerlink" title="弱引用（Weak Reference）"></a>弱引用（Weak Reference）</h5><ul>
<li>被弱引用关联的对象只能生存到下一次垃圾收集发生为止</li>
</ul>
<h5 id="虚引用（Phantom-Reference）"><a href="#虚引用（Phantom-Reference）" class="headerlink" title="虚引用（Phantom Reference）"></a>虚引用（Phantom Reference）</h5><ul>
<li>最弱的引用关系，无法造成任何影响，也无法通过虚引用获取一个对象实例</li>
<li>虚引用关联的唯一目的只是为了能在这个对象被垃圾收集器回收时候收到一个通知</li>
</ul>
<h4 id="引用计数式垃圾收集"><a href="#引用计数式垃圾收集" class="headerlink" title="引用计数式垃圾收集"></a>引用计数式垃圾收集</h4><h5 id="直接垃圾收集"><a href="#直接垃圾收集" class="headerlink" title="直接垃圾收集"></a>直接垃圾收集</h5><ul>
<li>主流Java虚拟机中均未涉及此算法</li>
<li>Objective-C采用此方式作为内存管理</li>
</ul>
<h4 id="追踪式垃圾收集（间接垃圾收集）"><a href="#追踪式垃圾收集（间接垃圾收集）" class="headerlink" title="追踪式垃圾收集（间接垃圾收集）"></a>追踪式垃圾收集（间接垃圾收集）</h4><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><h6 id="弱分代假说"><a href="#弱分代假说" class="headerlink" title="弱分代假说"></a>弱分代假说</h6><ul>
<li>大多数对象朝生夕死</li>
</ul>
<h6 id="强分代假说"><a href="#强分代假说" class="headerlink" title="强分代假说"></a>强分代假说</h6><ul>
<li><p>熬过多次垃圾收集过程的对象越难以消亡</p>
</li>
<li><p>根据以上假说多款收集器一致的设计原则：</p>
<ul>
<li>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储</li>
<li>根据分代设计理论，一般至少会把Java堆划分为新生代和老年代，在新生代中，每次垃圾收集会有大量的对象死亡，而每次存活的少量对象晋升到老年代存放</li>
</ul>
<p>跨代引用假说</p>
<ul>
<li>跨代引用相对于同代引用来说仅占少数</li>
<li>存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的</li>
<li>依据该假说，就不用为了少量的跨代引用扫描整个老年代，也不必浪费空间专门记录每个对象是否存在或存在哪些跨代引用，只需要在新生代建立一个全局的数据结构（记忆集），这个结构把老年代划分若干个小块，标识出老年代的哪一块内存会存在跨代引用</li>
<li>在Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描，这样就不用扫描整个老年代了</li>
</ul>
</li>
</ul>
<h4 id="垃圾收集分类"><a href="#垃圾收集分类" class="headerlink" title="垃圾收集分类"></a>垃圾收集分类</h4><h6 id="部分收集（Partial-GC）"><a href="#部分收集（Partial-GC）" class="headerlink" title="部分收集（Partial GC）"></a>部分收集（Partial GC）</h6><ul>
<li>目标不是完整收集整个Java堆的垃圾收集</li>
<li>新生代收集（<strong>Minor GC/Young GC</strong>）<ul>
<li>目标只是新生代的垃圾收集</li>
</ul>
</li>
<li>老年代收集（<strong>Major GC/Old GC</strong>）<ul>
<li>目标只是老年代的垃圾收集</li>
<li>目前只有CMS收集器会有单独收集老年代的行为</li>
</ul>
</li>
<li>混合收集（<strong>Mixed GC</strong>）<ul>
<li>目标是收集整个新生代以及部分老年代的垃圾收集</li>
<li>目前只有<strong>G1收集器</strong>有这种行为</li>
</ul>
</li>
</ul>
<h6 id="整堆收集（Full-GC）"><a href="#整堆收集（Full-GC）" class="headerlink" title="整堆收集（Full GC）"></a>整堆收集（Full GC）</h6><ul>
<li>目标收集整个Java堆和方法区的垃圾收集</li>
</ul>
<h4 id="垃圾收集器算法"><a href="#垃圾收集器算法" class="headerlink" title="垃圾收集器算法"></a>垃圾收集器算法</h4><h5 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h5><ul>
<li><p>分为“标记”和“清除”两个阶段</p>
<ul>
<li>首先标记所有要回收的对象，在标记完成后，统一回收掉所有被标记的对象</li>
<li>也可以反过来，标记存活的对象，统一回收所有未被标记的对象</li>
<li>标记的过程就是对象是否属于垃圾的判断过程</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li><p>执行效率不稳定</p>
<ul>
<li>如果堆中有大量的对象，其中大部分是要被回收堆，这时就需要大量标记和清除的动作，导致标记和清除过程的执行效率都随着对象的数量增长而降低</li>
</ul>
</li>
<li><p>内存空间碎片化问题</p>
<ul>
<li>标记/清除后产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序运行过程需要分配较大的对象时无法找到足够的连续内存而提前触发一次GC动作</li>
</ul>
</li>
</ul>
</li>
<li><p>在HotSpot虚拟机中</p>
<ul>
<li>关注低延迟的CMS收集器是基于标记-清除算法的，当内存空间碎片过多时CMS收集器就会采用标记-整理算法</li>
</ul>
<h5 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h5></li>
<li><p>简称复制算法，解决标记-清除算法面临大量对象执行效率低的问题</p>
<ul>
<li>就是将内存按容量划分为大小相等的两块，每次只是使用其中一块</li>
<li>当这一块内存快使用完，就将存活的对象复制到另一块内存上面，然后把使用的这一块内存空间一次清理掉</li>
</ul>
</li>
<li><p>好处</p>
<ul>
<li>不用考虑空间碎片化问题，只需移动堆顶指针，按顺序分配即可，这样实现简单高效</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>如果内存中多数对象都是存活的，就会存在大量内存复制的开销</li>
<li>将内存缩小为原来的一半，浪费了大量的空间</li>
</ul>
</li>
<li><p>根据以上特点提出更优化的半区复制分代策略（Appel式回收）</p>
<ul>
<li><p>Appel式回收的做法</p>
<ul>
<li><p>将新生代分为</p>
<ul>
<li>一块较大的Eden空间</li>
<li>两块较小的Survivor空间</li>
</ul>
</li>
<li><p>每次分配内存只使用Eden空间和其中一块Survivor空间，然后直接清理掉Eden空间和用过的那块Survivor空间</p>
</li>
<li><p>发生垃圾收集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用的Survivor空间</p>
</li>
<li><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是新生代可用内存空间为整个新生代容量的90%（Eden80%+Survivor10%）</p>
</li>
<li><p>但无法保证每次回收都有不多于10%对象存活，所以Appel式回收设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就要依赖其他内存区域（实际大多是老年代）进行分配担保（Handle Promotion）</p>
</li>
</ul>
</li>
<li><p>HotSpot的Serial/ParNew等新生代收集器均采用这种策略来设计新生代内存布局</p>
</li>
</ul>
<h5 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h5></li>
<li><p>标记过程仍与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都像内存空间一端移动，然后直接清理掉边界以外的内存</p>
</li>
<li><p>标记-清除和标记-整理本质区别：前者是非移动式的回收算法，后者是移动式的</p>
</li>
<li><p>缺点</p>
<ul>
<li><p>移动存活对象，在老年代中每次回收都有大量对象存活的区域，移动存活对象并更新所有引用这些对象的地方将会是极为繁重的操作</p>
</li>
<li><p>对象移动操作必须全程暂停用户程序才能进行</p>
</li>
<li><p>若不移动和整理存活对象，将会导致空间碎片化问题</p>
<ul>
<li>就只能依赖复杂的内存分配器和内存访问器来解决</li>
</ul>
</li>
</ul>
</li>
<li><p>在HotSpot虚拟机中</p>
<ul>
<li>关注吞吐量的收集器Parallel Scavenge基于标记-整理算法</li>
</ul>
</li>
</ul>
<h4 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><ul>
<li><p>在JDK1.3以前是HotSpot虚拟机新生代收集器的唯一选择</p>
</li>
<li><p>客户端模式下默认新生代收集器</p>
</li>
<li><p>单线程工作的收集器</p>
</li>
<li><p>优势</p>
<ul>
<li>和其他单线程收集器相比，简单而高效</li>
<li>对于内存资源受限的环境，是所有收集器里额外内存消耗最小的</li>
<li>对于单核处理器或处理器核心较少的环境来说，Serial收集器由于没有线程交互的开销，可以获得最高的单线程收集效率</li>
</ul>
</li>
</ul>
<h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><ul>
<li>是Serial收集器的多线程并行版本</li>
<li>ParNew收集器是激活CMS收集器后的默认新生代收集器</li>
<li>从JDK9 G1收集器的出现，CMS+ParNew收集器的组合就不再是官方推荐的服务器模式下的默认收集器</li>
<li>ParNew收集器默认开启的收集线程数与处理器核心数量相同，也可以使用参数来限制垃圾收集器的线程数</li>
</ul>
<h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><ul>
<li><p>也是新生代收集器</p>
</li>
<li><p>基于标记-复制算法实现的收集器</p>
</li>
<li><p>也是并行收集的多线程收集器</p>
</li>
<li><p>特点</p>
<ul>
<li>与其他收集器关注点不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间</li>
<li>Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量</li>
<li>所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</li>
<li>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 运行垃圾收集器时间）</li>
<li>所以Parallel Scavenge收集器又被称作“吞吐量优先收集器”</li>
</ul>
</li>
<li><p>Parallel Scavenge收集器提供了两个参数用来精确控制吞吐量</p>
<ul>
<li>控制最大垃圾收集停顿时间的-XX:MaxGCPauseMillis参数</li>
<li>直接设置吞吐量大小的-XX:GCTimeRatio参数</li>
</ul>
</li>
</ul>
<h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h5><ul>
<li><p>Serial Old收集器是Serial收集器的老年代版本</p>
</li>
<li><p>也是一个单线程收集器</p>
</li>
<li><p>使用标记-整理算法实现的收集器</p>
</li>
<li><p>主要也是提供客户端模式下HotSpot虚拟机使用</p>
</li>
<li><p>若是用于服务端模式下，则可能有两种用途</p>
<ul>
<li>在JDK5及以前的版本中与Parallel Scavenge收集器搭配使用</li>
<li>是作为CMS收集器发生失败时的后备预案，在并发收集发生Concurrent Mode Failure时使用</li>
</ul>
</li>
</ul>
<h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><ul>
<li>Parallel Old收集器是Parallel Scavenge收集器的老年代版本</li>
<li>支持多线程并发收集，基于标记-整理算法实现</li>
<li>从JDK6开始提供，为了解决Parallel Scavenge收集器的尴尬状态，原因在于Parallel Scavenge收集器，老年代除了Serial Old收集器以外别无选择，无法与其他表现良好的老年代收集器配合工作，如CMS收集器</li>
<li>吞吐量优先收集器的组合，在注重吞吐量或者处理器资源较为稀缺的场合，可以考虑Parallel Scavenge加Parallel Old收集器这个组合</li>
</ul>
<h5 id="CMS（Concurrent-Mark-Sweep）收集器"><a href="#CMS（Concurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Concurrent Mark Sweep）收集器"></a>CMS（Concurrent Mark Sweep）收集器</h5><h6 id="什么是CMS收集器"><a href="#什么是CMS收集器" class="headerlink" title="什么是CMS收集器"></a>什么是CMS收集器</h6><ul>
<li>以获取最短回收停顿时间为目标的收集器</li>
<li>从名字来看CMS收集器是基于标记-清除算法实现的</li>
<li>在JDK9以后不官方不推荐使用CMS收集器</li>
</ul>
<h6 id="CMS-工作过程"><a href="#CMS-工作过程" class="headerlink" title="CMS 工作过程"></a>CMS 工作过程</h6><ul>
<li><p>初始标记（CMS initial mark）</p>
<ul>
<li>标记一下GC Roots能直接关联到到对象，速度很快，需要停顿用户线程</li>
</ul>
</li>
<li><p>并发标记（CMS concurrent mark）</p>
<ul>
<li>从GC Roots直接关联对象开始遍历整个对象图的过程，该过程耗时长但不需要停顿用户线程</li>
</ul>
</li>
<li><p>重新标记（CMS remark）</p>
<ul>
<li>修正并发标记期间，因用户线程继续运作而导致标记产生变动但那一部分对象的标记记录，该阶段停顿的时间比初始标记要长一些，但也远比并发标记的时间要短</li>
</ul>
</li>
<li><p>并发清除（CMS concurrent sweep）</p>
<ul>
<li>清理删掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以该阶段也是可以和用户线程同时并发</li>
</ul>
</li>
</ul>
<h6 id="CMS-优点"><a href="#CMS-优点" class="headerlink" title="CMS 优点"></a>CMS 优点</h6><ul>
<li>并发收集</li>
<li>低停顿</li>
</ul>
<h6 id="CMS-缺点"><a href="#CMS-缺点" class="headerlink" title="CMS 缺点"></a>CMS 缺点</h6><ul>
<li><p>对处理器资源非常敏感，在并发阶段，会导致应用程序变慢，降低了总吞吐量</p>
</li>
<li><p>CMS收集器默认启动的回收线程数是（处理器核心数量+3）/4</p>
<ul>
<li>如果处理器核心数在4个以上，并发回收时垃圾收集器只占用不超过25%的处理器运算资源，并且会随着处理器核心数增加而下降</li>
<li>当处理器核心数不足4个时，CMS收集器对用户程序的影响就可能变得很大</li>
</ul>
</li>
<li><p>由于CMS收集器无法处理“浮动垃圾”，有可能出现“Concurrent Mode Failure”失败进而导致一次完全“Stop The World”的Full GC的产生</p>
<ul>
<li>浮动垃圾：在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集处理掉它们，只好留到下一次清理，这一部分垃圾就是浮动垃圾</li>
</ul>
</li>
<li><p>由于CMS是一款基于“标记-清除”算法实现的收集器，就会造成大量空间碎片产生，如果空间碎片过多时，当需要足够大大连续空间来分配大对象大时候，会不得不提前触发Full GC的情况</p>
<ul>
<li><p>解决方案</p>
<ul>
<li>CMS收集器提供一个-XX:+UseCMSCompactAtFullCollection开关参数（默认开启，JDK9开始弃用），用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，（在Shenandoah和ZGC出现前）是无法并发的</li>
<li>空间碎片问题虽然解决了，但停顿时间又会变长，因此虚拟机提供了参数-XX:CMSFullGCsBeforeCompaction（JDK9开始弃用），用于要求CMS收集器在执行过若干次（数量由参数值决定）不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理（默认值为0，表示每次进入Full GC时都进行碎片整理）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="Garbage-First（G1）收集器"><a href="#Garbage-First（G1）收集器" class="headerlink" title="Garbage First（G1）收集器"></a>Garbage First（G1）收集器</h5><h6 id="什么是G1收集器"><a href="#什么是G1收集器" class="headerlink" title="什么是G1收集器"></a>什么是G1收集器</h6><ul>
<li>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式</li>
<li>从JDK7确立项目目标，G1收集器就被视为JDK7中HotSpot虚拟机的一项重要进化特征，直到JDK8 Update 40之后，这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”</li>
<li>面向服务端应用的垃圾收集器，HotSpot期望它代替CMS收集器，在JDK9中G1就代替Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器，而CMS则标记为不推荐使用的收集器，在未来CMS可能会被废弃</li>
</ul>
<h6 id="G1收集器设计模式"><a href="#G1收集器设计模式" class="headerlink" title="G1收集器设计模式"></a>G1收集器设计模式</h6><ul>
<li><p>G1收集器以前的其他收集器，垃圾收集的目标范围要么是整个新生代（Minor GC），要么是老年代（Major GC），要么是整个Java堆（Full GC）；而G1跳出了这个樊笼，它可以面对堆内存任何部分来组成回收集（Collection Set，简称CSet）进行回收，衡量标准不在是属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的混合收集（Mixed GC）模式</p>
</li>
<li><p>G1开创基于Region的堆内存布局是它能够实现这个目标的关键</p>
</li>
<li><p>虽然G1也遵循分代收集理论设计的，但在堆内存但布局与其他收集器有很大差异</p>
<ul>
<li>G1不再坚持固定大小以及固定数量但分代区域划分，而是把连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Edge空间、Survivor空间或者老年代空间</li>
<li>G1收集器能根据不同的Region采用不同的策略去处理</li>
<li>Region中还有一类特殊的Humongous区域，专门用来存储大对象，G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象</li>
<li>每个Region的大小可以通过参数-XX:G1HeapRegionSize设定，取值范围为1MB-32MB，且为2的n次幂</li>
<li>对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li>
</ul>
</li>
<li><p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域（不需要连续）的动态集合</p>
<ul>
<li>G1收集器之所以能够建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集</li>
<li>处理思路是让G1收集器跟踪各个Region里面的垃圾堆积的“价值”大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间（-XX:MaxGCPauseMillis指定，默认是200ms），优先处理回收价值受益最大的那些Region，这也就是“Garbage First”名字的由来</li>
<li>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率</li>
</ul>
</li>
</ul>
<h6 id="G1收集器运作过程（不计算用户线程运行过程中的动作）"><a href="#G1收集器运作过程（不计算用户线程运行过程中的动作）" class="headerlink" title="G1收集器运作过程（不计算用户线程运行过程中的动作）"></a>G1收集器运作过程（不计算用户线程运行过程中的动作）</h6><ul>
<li><p>初始标记（Initial Marking）</p>
<ul>
<li>标记GC Roots能直接关联到到对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象</li>
<li>该阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实行并没有额外的停顿</li>
</ul>
</li>
<li><p>并发标记（Concurrent Marking）</p>
<ul>
<li>从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时比较长，但可与用户线程并发执行</li>
<li>当扫描图扫描完成后，还要重新处理SATB记录下的在并发时有引用变动的对象</li>
</ul>
</li>
<li><p>最终标记（Final Marking）</p>
<ul>
<li>对用户线程做另一个短暂对暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li>
</ul>
</li>
<li><p>筛选回收（Live Data Counting and Evacuation）</p>
<ul>
<li><p>负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来指定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间</p>
</li>
<li><p>这里的操作涉及存活对象的移动，是必须暂停用户线程，由多条收集器线程并行完成的</p>
</li>
<li><p>G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望</p>
</li>
</ul>
</li>
</ul>
<h6 id="G1收集器特点"><a href="#G1收集器特点" class="headerlink" title="G1收集器特点"></a>G1收集器特点</h6><ul>
<li><p>可由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿时间，可让G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡</p>
<ul>
<li>默认停顿时间200ms，必须保证“期望值”符合实际</li>
<li>若是停顿时间设置很低，则可能出现由于停顿目标时间太短，导致每次选出来的回收集只占堆内存很小的一部分，收集器收集的速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积，最终引发Full GC而降低性能</li>
<li>所以期望停顿时间设置为100-200ms或200-300ms是比较合理的</li>
</ul>
</li>
<li><p>从G1开始，先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率（Allocation Rate），而不是追求一次把整个Java堆全部清理干净</p>
<ul>
<li>这样应用在分配，同时收集器在收集，只要收集的速度能跟上对象分配的速度，那这一切能运作得很完美</li>
</ul>
</li>
</ul>
<h6 id="G1收集器相比CMS的优点"><a href="#G1收集器相比CMS的优点" class="headerlink" title="G1收集器相比CMS的优点"></a>G1收集器相比CMS的优点</h6><ul>
<li><p>G1从整体来看是基于“标记-整理”算法实现的收集器，从局部上看（两个Region之间）又是基于“标记-复制”算法实现，无论如何，这两种算法在运行期间都不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存</p>
<ul>
<li>有利于应用程序长时间运行</li>
<li>分配大对象时不容易造成无法找到连续内存空间而提前触发一次收集</li>
</ul>
</li>
<li><p>可以自定义指定最大停顿时间</p>
</li>
<li><p>分Region的内存布局</p>
</li>
<li><p>按收益动态确定回收集</p>
</li>
</ul>
<h6 id="G1收集器相比CMS的缺点"><a href="#G1收集器相比CMS的缺点" class="headerlink" title="G1收集器相比CMS的缺点"></a>G1收集器相比CMS的缺点</h6><ul>
<li><p>在运行过程中，G1垃圾收集器内存占用（Footprint）要比CMS要高</p>
<ul>
<li>G1和CMS都使用卡表来处理跨代指针，但G1的卡表实现更复杂，堆中每个Region，无论扮演新生代还是老年代角色，都必须有一份卡表，导致G1的记忆集（和其他内存消耗）可能会占整个堆容量的20%乃至更多的内存空间</li>
<li>CMS的卡表就相当简单，只有唯一一份，而且只需要处理老年代到新生代的引用，反过来不需要，由于新生代的对象具有朝生夕灭的不稳定性，引用变化频繁，能省下这个区域的维护开销是很划算的</li>
</ul>
</li>
<li><p>程序运行时的额外执行负载（Overload）要比CMS高</p>
<ul>
<li><p>由于G1和CMS收集器各自实现特点导致用户程序运行时的负载会有不同，譬如它们都使用写屏障，CMS用写后屏障来更新维护卡表</p>
</li>
<li><p>G1除了使用写后屏障来进行同样的卡表维护操作外，为了实现原始快照搜索（SATB）算法，还需要使用写前屏障来跟踪并发时的指针变化情况</p>
<ul>
<li>相比增量更新算法，原始快照搜索能够减少并发标记和重新标记阶段的消耗，避免CMS那样在最终标记阶段停顿时间过长的缺点，但是在用户程序运行过程中确实会产生由跟踪引用变化带来的额外负担</li>
<li>由于G1对写屏障的复杂操作要比CMS消耗更多对运算资源，所以CMS的写屏障实现时直接的同步操作， 而G1就不得不将其实现为类似于消息队列的结构，把写前屏障和写后屏障中要做的事情都放到队列里，然后再异步处理</li>
</ul>
</li>
</ul>
</li>
<li><p>以上优缺点仅仅是针对G1和CMS两款垃圾收集器单独某方面的实现细节的定性分析，通常说哪款收集器要更好、要好上多少，往往是针对具体场景才能做的定量比较</p>
<ul>
<li>目前在小内存应用上CMS的表现大概率仍然会优于G1收集器</li>
<li>而在大内存应用上G1则大多能发挥其优势</li>
<li>这个优劣势的Java堆容量平衡点通常在6GB-8GB之间</li>
<li>随着HotSpot对G1对不断优化，也会让对比结果继续向G1倾斜</li>
</ul>
</li>
</ul>
<h5 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h5><ul>
<li><p>垃圾收集器三项重要指标</p>
<ul>
<li>内存占用（Footprint）</li>
<li>吞吐量（Throughput）</li>
<li>延迟（Latency）</li>
</ul>
</li>
<li><p>实验状态的低延迟垃圾收集器</p>
<ul>
<li>Shenandoah收集器（存在于OpenJDK，而不存在于OracleJDK）</li>
<li>ZGC收集器</li>
</ul>
</li>
</ul>
<h5 id="不垃圾回收的垃圾收集器"><a href="#不垃圾回收的垃圾收集器" class="headerlink" title="不垃圾回收的垃圾收集器"></a>不垃圾回收的垃圾收集器</h5><h6 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h6><ul>
<li>JDK11推出的不能够进行垃圾收集的垃圾收集器</li>
<li>适用于运行数分钟或者数秒，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div>若是觉得合胃口，就请我喝杯咖啡.</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Mr.zxb 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="Mr.zxb 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/GC/" rel="tag"># GC</a>
              <a href="/tags/Jvm%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" rel="tag"># Jvm内存分配</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" rel="prev" title="每天一个设计模式之策略模式">
      <i class="fa fa-chevron-left"></i> 每天一个设计模式之策略模式
    </a></div>
      <div class="post-nav-item">
    <a href="/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="next" title="每天一个设计模式之观察者模式">
      每天一个设计模式之观察者模式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%EF%BC%88Garbage-Collection%EF%BC%8CGC%EF%BC%89"><span class="nav-number">1.</span> <span class="nav-text">垃圾收集器（Garbage Collection，GC）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%9A%84%E7%A5%9E%E7%A7%98%E9%9D%A2%E7%BA%B1"><span class="nav-number">1.1.</span> <span class="nav-text">内存分配与回收的神秘面纱</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="nav-number">1.1.1.</span> <span class="nav-text">堆内存划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Edge%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">1.1.2.</span> <span class="nav-text">对象优先在Edge区分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.1.3.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">1.1.4.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A"><span class="nav-number">1.1.5.</span> <span class="nav-text">动态对象年龄判定</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E6%B4%BB%E7%9D%80%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text">如何判断对象活着？</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.1.</span> <span class="nav-text">引用计数算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.</span> <span class="nav-text">可达性分析算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">什么是可达性分析算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-GC-Roots%E5%AF%B9%E8%B1%A1"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">什么是 GC Roots对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8"><span class="nav-number">1.3.</span> <span class="nav-text">再谈引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%EF%BC%88Strongly-Reference%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">强引用（Strongly Reference）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AF%E5%BC%95%E7%94%A8%EF%BC%88Soft-Reference%EF%BC%89"><span class="nav-number">1.3.2.</span> <span class="nav-text">软引用（Soft Reference）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%EF%BC%88Weak-Reference%EF%BC%89"><span class="nav-number">1.3.3.</span> <span class="nav-text">弱引用（Weak Reference）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%99%9A%E5%BC%95%E7%94%A8%EF%BC%88Phantom-Reference%EF%BC%89"><span class="nav-number">1.3.4.</span> <span class="nav-text">虚引用（Phantom Reference）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">1.4.</span> <span class="nav-text">引用计数式垃圾收集</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86"><span class="nav-number">1.4.1.</span> <span class="nav-text">直接垃圾收集</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%BD%E8%B8%AA%E5%BC%8F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%88%E9%97%B4%E6%8E%A5%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%EF%BC%89"><span class="nav-number">1.5.</span> <span class="nav-text">追踪式垃圾收集（间接垃圾收集）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="nav-number">1.5.1.</span> <span class="nav-text">分代收集算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%B1%E5%88%86%E4%BB%A3%E5%81%87%E8%AF%B4"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">弱分代假说</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%BA%E5%88%86%E4%BB%A3%E5%81%87%E8%AF%B4"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">强分代假说</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%88%86%E7%B1%BB"><span class="nav-number">1.6.</span> <span class="nav-text">垃圾收集分类</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%83%A8%E5%88%86%E6%94%B6%E9%9B%86%EF%BC%88Partial-GC%EF%BC%89"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">部分收集（Partial GC）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B4%E5%A0%86%E6%94%B6%E9%9B%86%EF%BC%88Full-GC%EF%BC%89"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">整堆收集（Full GC）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.</span> <span class="nav-text">垃圾收集器算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="nav-number">1.7.1.</span> <span class="nav-text">标记-清除算法（Mark-Sweep）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="nav-number">1.7.2.</span> <span class="nav-text">标记-复制算法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88Mark-Compact%EF%BC%89"><span class="nav-number">1.7.3.</span> <span class="nav-text">标记-整理算法（Mark-Compact）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.</span> <span class="nav-text">经典垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.1.</span> <span class="nav-text">Serial收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ParNew%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.2.</span> <span class="nav-text">ParNew收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.3.</span> <span class="nav-text">Parallel Scavenge收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.4.</span> <span class="nav-text">Serial Old收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Parallel-Old%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.5.</span> <span class="nav-text">Parallel Old收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CMS%EF%BC%88Concurrent-Mark-Sweep%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.6.</span> <span class="nav-text">CMS（Concurrent Mark Sweep）收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCMS%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.6.1.</span> <span class="nav-text">什么是CMS收集器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CMS-%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B"><span class="nav-number">1.8.6.2.</span> <span class="nav-text">CMS 工作过程</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CMS-%E4%BC%98%E7%82%B9"><span class="nav-number">1.8.6.3.</span> <span class="nav-text">CMS 优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CMS-%E7%BC%BA%E7%82%B9"><span class="nav-number">1.8.6.4.</span> <span class="nav-text">CMS 缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Garbage-First%EF%BC%88G1%EF%BC%89%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.7.</span> <span class="nav-text">Garbage First（G1）收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFG1%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.7.1.</span> <span class="nav-text">什么是G1收集器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.8.7.2.</span> <span class="nav-text">G1收集器设计模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E8%BF%90%E4%BD%9C%E8%BF%87%E7%A8%8B%EF%BC%88%E4%B8%8D%E8%AE%A1%E7%AE%97%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%8A%A8%E4%BD%9C%EF%BC%89"><span class="nav-number">1.8.7.3.</span> <span class="nav-text">G1收集器运作过程（不计算用户线程运行过程中的动作）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%89%B9%E7%82%B9"><span class="nav-number">1.8.7.4.</span> <span class="nav-text">G1收集器特点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E6%AF%94CMS%E7%9A%84%E4%BC%98%E7%82%B9"><span class="nav-number">1.8.7.5.</span> <span class="nav-text">G1收集器相比CMS的优点</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#G1%E6%94%B6%E9%9B%86%E5%99%A8%E7%9B%B8%E6%AF%94CMS%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">1.8.7.6.</span> <span class="nav-text">G1收集器相比CMS的缺点</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.8.</span> <span class="nav-text">低延迟垃圾收集器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.9.</span> <span class="nav-text">不垃圾回收的垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Epsilon%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">1.8.9.1.</span> <span class="nav-text">Epsilon收集器</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Mr.zxb"
      src="https://tva1.sinaimg.cn/large/008aQ1h9ly1ghqb9xxkl6j31ig3401kx.jpg">
  <p class="site-author-name" itemprop="name">Mr.zxb</p>
  <div class="site-description" itemprop="description">个人技术博客，一个沉淀知识的地方</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chivalry727" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chivalry727" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.google.com.hk/" title="Google → https:&#x2F;&#x2F;www.google.com.hk&#x2F;" rel="noopener" target="_blank"><i class="fab fa-google fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://youtube.com/" title="YouTube → https:&#x2F;&#x2F;youtube.com&#x2F;" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mr.zxb</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">57k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">52 分钟</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  

</body>
</html>
